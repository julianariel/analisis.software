<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0037)http://www.bullseye.com/coverage.html -->
<HTML><HEAD><TITLE>Code Coverage Analysis</TITLE>
<META http-equiv=Content-Type content=text/html;charset=utf-8>
<META 
content="A complete description of code coverage analysis, a software testing technique." 
name=description>
<META 
content="code coverage, coverage analysis, coverage analyzer, test coverage, coverage testing, software testing" 
name=keywords><LINK href="Code Coverage Analysis_archivos/style.css" 
type=text/css rel=stylesheet><LINK href="favicon-coverage.ico" 
rel="shortcut icon">
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY>
<H1>Code Coverage Analysis</H1>
<P>This paper gives a complete description of code coverage analysis (test 
coverage analysis), a software testing technique. 
<DIV style="FONT-SIZE: 0.7em; FONT-STYLE: italic">
<P>By Steve Cornett. Copyright © <A href="http://www.bullseye.com/">Bullseye 
Testing Technology</A>. All rights reserved. Redistribution in whole or in part 
is prohibited without permission. 
<P>Last updated 3-Oct-2002. </P></DIV>
<H2>Contents</H2>
<UL>
  <LI><A href="http://www.bullseye.com/coverage.html#intro">Introduction</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#struct">Structural Testing 
  and Functional Testing</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#premise">The Premise</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#basic">Basic Measures</A> 
  <UL>
    <LI><A 
    href="http://www.bullseye.com/coverage.html#basic_statement">Statement 
    Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#basic_decision">Decision 
    Coverage</A> 
    <LI><A 
    href="http://www.bullseye.com/coverage.html#basic_condition">Condition 
    Coverage</A> 
    <LI><A 
    href="http://www.bullseye.com/coverage.html#basic_conditionMultiple">Multiple 
    Condition Coverage</A> 
    <LI><A 
    href="http://www.bullseye.com/coverage.html#basic_conditionDecision">Condition/Decision 
    Coverage</A> 
    <LI><A 
    href="http://www.bullseye.com/coverage.html#basic_conditionDecisionModified">Modified 
    Condition/Decision Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#basic_path">Path 
    Coverage</A> </LI></UL>
  <LI><A href="http://www.bullseye.com/coverage.html#other">Other Measures</A> 
  <UL>
    <LI><A href="http://www.bullseye.com/coverage.html#other_function">Function 
    Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_call">Call 
    Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_lcsaj">Linear Code 
    Sequence and Jump (LCSAJ) Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_dataFlow">Data Flow 
    Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_object">Object Code 
    Branch Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_loop">Loop 
    Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_race">Race 
    Coverage</A> 
    <LI><A 
    href="http://www.bullseye.com/coverage.html#other_relational">Relational 
    Operator Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_mutation">Weak 
    Mutation Coverage</A> 
    <LI><A href="http://www.bullseye.com/coverage.html#other_table">Table 
    Coverage</A> </LI></UL>
  <LI><A href="http://www.bullseye.com/coverage.html#compare">Comparing 
  Measures</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#release">Coverage Goal for 
  Release</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#intermediate">Intermediate 
  Coverage Goals</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#summary">Summary</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#refer">References</A> 
  <LI><A href="http://www.bullseye.com/coverage.html#glossary">Glossary</A> 
</LI></UL>
<H2><A name=intro>Introduction</A></H2>
<P><DFN>Code coverage analysis</DFN> is the process of: 
<UL>
  <LI>Finding areas of a program not exercised by a set of test cases, 
  <LI>Creating additional test cases to increase coverage, and 
  <LI>Determining a quantitative measure of code coverage, which is an indirect 
  measure of quality. </LI></UL>
<P>An optional aspect of code coverage analysis is: 
<UL>
  <LI>Identifying redundant test cases that do not increase coverage. </LI></UL>
<P>A code <DFN>coverage analyzer</DFN> automates this process. 
<P>You use coverage analysis to assure quality of your set of tests, not the 
quality of the actual product. You do not generally use a coverage analyzer when 
running your set of tests through your release candidate. Coverage analysis 
requires access to test program source code and often requires recompiling it 
with a special command. 
<P>This paper discusses the details you should consider when planning to add 
coverage analysis to your test plan. Coverage analysis has certain strengths and 
weaknesses. You must choose from a range of measurement methods. You should 
establish a minimum percentage of coverage, to determine when to stop analyzing 
coverage. Coverage analysis is one of many testing techniques; you should not 
rely on it alone. 
<P>Code coverage analysis is sometimes called <DFN>test coverage analysis</DFN>. 
The two terms are synonymous. The academic world more often uses the term "test 
coverage" while practitioners more often use "code coverage". Likewise, a 
coverage analyzer is sometimes called a <DFN>coverage monitor</DFN>. I prefer 
the practitioner terms. 
<H2><A name=struct>Structural Testing and Functional Testing</A></H2>
<P>Code coverage analysis is a structural testing technique (AKA glass box 
testing and white box testing). Structural testing compares test program 
behavior against the apparent intention of the source code. This contrasts with 
functional testing (AKA black-box testing), which compares test program behavior 
against a requirements specification. Structural testing examines how the 
program works, taking into account possible pitfalls in the structure and logic. 
Functional testing examines what the program accomplishes, without regard to how 
it works internally. 
<P>Structural testing is also called path testing since you choose test cases 
that cause paths to be taken through the structure of the program. Do not 
confuse path testing with the <A 
href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A> 
measure, explained later. 
<P>At first glance, structural testing seems unsafe. Structural testing cannot 
find <A href="http://www.bullseye.com/coverage.html#glossary_error">errors</A> 
of omission. However, requirements specifications sometimes do not exist, and 
are rarely complete. This is especially true near the end of the product 
development time line when the requirements specification is updated less 
frequently and the product itself begins to take over the role of the 
specification. The difference between functional and structural testing blurs 
near release time. 
<H2><A name=premise>The Premise</A></H2>
<P>The basic assumptions behind coverage analysis tell us about the strengths 
and limitations of this testing technique. Some fundamental assumptions are 
listed below. 
<UL>
  <LI><A href="http://www.bullseye.com/coverage.html#glossary_fault">Faults</A> 
  relate to control flow and you can expose <A 
  href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A> by 
  varying the control flow [<A 
  href="http://www.bullseye.com/coverage.html#beizer1990">Beizer1990</A> p.60]. 
  For example, a programmer wrote "<CODE>if (c)</CODE>" rather than "<CODE>if 
  (!c)</CODE>". 
  <LI>You can look for <A 
  href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A> 
  without knowing what <A 
  href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A> 
  might occur and all tests are <EM>reliable</EM>, in that successful test runs 
  imply program correctness [<A 
  href="http://www.bullseye.com/coverage.html#morell1990">Morell1990</A>]. The 
  tester understands what a correct version of the program would do and can 
  identify differences from the correct behavior. 
  <LI>Other assumptions include achievable specifications, no <A 
  href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A> of 
  omission, and no unreachable code. </LI></UL>
<P>Clearly, these assumptions do not always hold. Coverage analysis exposes some 
plausible <A 
href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A> but does 
not come close to exposing all classes of <A 
href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A>. Coverage 
analysis provides more benefit when applied to an application that makes a lot 
of decisions rather than data-centric applications, such as a database 
application. 
<H2><A name=basic>Basic Measures</A></H2>
<P>A large variety of coverage measures exist. Here is a description of some 
fundamental measures and their strengths and weaknesses. 
<H3><A name=basic_statement>Statement Coverage </A></H3>
<P>This measure reports whether each executable statement is encountered. 
<P>Also known as: line coverage, segment coverage [<A 
href="http://www.bullseye.com/coverage.html#ntafos1988">Ntafos1988</A>], C1 [<A 
href="http://www.bullseye.com/coverage.html#beizer1990">Beizer1990</A> p.75] and 
basic block coverage. Basic block coverage is the same as statement coverage 
except the unit of code measured is each sequence of non-branching statements. 
<P>The chief advantage of this measure is that it can be applied directly to 
object code and does not require processing source code. Performance profilers 
commonly implement this measure. 
<P>The chief disadvantage of statement coverage is that it is insensitive to 
some control structures. For example, consider the following C/C++ code 
fragment: <PRE>int* p = NULL;
if (condition)
    p = &amp;variable;
*p = 123;
</PRE>
<P>Without a test case that causes <CODE>condition</CODE> to evaluate false, 
statement coverage rates this code fully covered. In fact, if 
<CODE>condition</CODE> ever evaluates false, this code <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">fails</A>. This is 
the most serious shortcoming of statement coverage. If-statements are very 
common. 
<P>Statement coverage does not report whether loops reach their termination 
condition - only whether the loop body was executed. With C, C++, and Java, this 
limitation affects loops that contain <CODE>break</CODE> statements. 
<P>Since <CODE>do</CODE>-<CODE>while</CODE> loops always execute at least once, 
statement coverage considers them the same rank as non-branching statements. 
<P>Statement coverage is completely insensitive to the logical operators 
(<CODE>||</CODE> and <CODE>&amp;&amp;</CODE>). 
<P>Statement coverage cannot distinguish consecutive <CODE>switch</CODE> labels. 

<P>Test cases generally correlate more to decisions than to statements. You 
probably would not have 10 separate test cases for a sequence of 10 
non-branching statements; you would have only one test case. For example, 
consider an if-else statement containing one statement in the then-clause and 99 
statements in the else-clause. After exercising one of the two possible paths, 
statement coverage gives extreme results: either 1% or 99% coverage. Basic block 
coverage eliminates this problem. 
<P>One argument in favor of statement coverage over other measures is that <A 
href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A> are 
evenly distributed through code; therefore the percentage of executable 
statements covered reflects the percentage of faults discovered. However, one of 
our fundamental assumptions is that faults are related to control flow, not 
computations. Additionally, we could reasonably expect that programmers strive 
for a relatively constant ratio of branches to statements. 
<P>In summary, this measure is affected more by computational statements than by 
decisions. 
<H3><A name=basic_decision>Decision Coverage </A></H3>
<P>This measure reports whether boolean expressions tested in control structures 
(such as the <CODE>if</CODE>-statement and <CODE>while</CODE>-statement) 
evaluated to both true and false. The entire boolean expression is considered 
one true-or-false predicate regardless of whether it contains logical-and or 
logical-or operators. Additionally, this measure includes coverage of 
<CODE>switch</CODE>-statement cases, exception handlers, and interrupt handlers. 

<P>Also known as: branch coverage, all-edges coverage [<A 
href="http://www.bullseye.com/coverage.html#roper1994">Roper1994</A> p.58], 
basis path coverage [<A 
href="http://www.bullseye.com/coverage.html#roper1994">Roper1994</A> p.48], C2 
[<A href="http://www.bullseye.com/coverage.html#beizer1990">Beizer1990</A> 
p.75], decision-decision-path testing [<A 
href="http://www.bullseye.com/coverage.html#roper1994">Roper1994</A> p.39]. 
"Basis path" testing selects paths that achieve decision coverage. 
<P>This measure has the advantage of simplicity without the problems of <A 
href="http://www.bullseye.com/coverage.html#basic_statement">statement 
coverage</A>. 
<P>A disadvantage is that this measure ignores branches within boolean 
expressions which occur due to short-circuit operators. For example, consider 
the following C/C++/Java code fragment: <PRE>if (condition1 &amp;&amp; (condition2 || function1()))
    statement1;
else
    statement2;
</PRE>
<P>This measure could consider the control structure completely exercised 
without a call to <CODE>function1</CODE>. The test expression is true when 
<CODE>condition1</CODE> is true and <CODE>condition2</CODE> is true, and the 
test expression is false when <CODE>condition1</CODE> is false. In this 
instance, the short-circuit operators preclude a call to <CODE>function1</CODE>. 

<H3><A name=basic_condition>Condition Coverage </A></H3>
<P>Condition coverage reports the true or false outcome of each boolean 
sub-expression, separated by logical-and and logical-or if they occur. Condition 
coverage measures the sub-expressions independently of each other. 
<P>This measure is similar to <A 
href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A> but has better sensitivity to the control flow. 
<P>However, full condition coverage does not guarantee full <A 
href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A>. For example, consider the following C++/Java fragment. <PRE>bool f(bool e) { return false; }
bool a[2] = { false, false };
if (f(a &amp;&amp; b)) ...
if (a[int(a &amp;&amp; b)]) ...
if ((a &amp;&amp; b) ? false : false) ...
</PRE>
<P>All three of the if-statements above branch false regardless of the values of 
<CODE>a</CODE> and <CODE>b</CODE>. However if you exercise this code with 
<CODE>a</CODE> and <CODE>b</CODE> having all possible combinations of values, 
condition coverage reports full coverage. 
<H3><A name=basic_conditionMultiple>Multiple Condition Coverage </A></H3>
<P>Multiple condition coverage reports whether every possible combination of 
boolean sub-expressions occurs. As with <A 
href="http://www.bullseye.com/coverage.html#basic_condition">condition 
coverage</A>, the sub-expressions are separated by logical-and and logical-or, 
when present. The test cases required for full multiple condition coverage of a 
condition are given by the logical operator truth table for the condition. 
<P>For languages with short circuit operators such as C, C++, and Java, an 
advantage of multiple condition coverage is that it requires very thorough 
testing. For these languages, multiple condition coverage is very similar to <A 
href="http://www.bullseye.com/coverage.html#basic_condition">condition 
coverage</A>. 
<P>A disadvantage of this measure is that it can be tedious to determine the 
minimum set of test cases required, especially for very complex boolean 
expressions. An additional disadvantage of this measure is that the number of 
test cases required could vary substantially among conditions that have similar 
complexity. For example, consider the following two C/C++/Java conditions. <PRE>a &amp;&amp; b &amp;&amp; (c || (d &amp;&amp; e))
((a || b) &amp;&amp; (c || d)) &amp;&amp; e
</PRE>
<P>To achieve full multiple condition coverage, the first condition requires 6 
test cases while the second requires 11. Both conditions have the same number of 
operands and operators. 
<P>As with <A 
href="http://www.bullseye.com/coverage.html#basic_condition">condition 
coverage</A>, multiple condition coverage does not include <A 
href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A>. 
<P>For languages without short circuit operators such as Visual Basic and 
Pascal, multiple condition coverage is effectively <A 
href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A> 
(described below) for logical expressions, with the same advantages and 
disadvantages. Consider the following Visual Basic code fragment. <PRE>If a And b Then
...
</PRE>
<P>Multiple condition coverage requires four test cases, for each of the 
combinations of a and b both true and false. As with <A 
href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A> each 
additional logical operator doubles the number of test cases required. 
<H3><A name=basic_conditionDecision>Condition/Decision Coverage </A></H3>
<P>Condition/Decision Coverage is a hybrid measure composed by the union of <A 
href="http://www.bullseye.com/coverage.html#basic_condition">condition 
coverage</A> and <A 
href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A>. 
<P>It has the advantage of simplicity but without the shortcomings of its 
component measures. 
<P><A href="http://www.bullseye.com/index.html">BullseyeCoverage</A> measures 
condition/decision coverage. 
<H3><A name=basic_conditionDecisionModified>Modified Condition/Decision Coverage 
</A></H3>
<P>Also known as MC/DC and MCDC. 
<P>This measure requires enough test cases to verify every condition can affect 
the result of its encompassing decision [<A 
href="http://www.bullseye.com/coverage.html#Chilenski1994">Chilenski1994</A>]. 
This measure was created at <A href="http://www.boeing.com/">Boeing</A> and is 
required for aviation software by <A 
href="http://www.bullseye.com/coverage.html#do178b">RCTA/DO-178B</A>. 
<P>For C, C++ and Java, this measure requires exactly the same test cases as <A 
href="http://www.bullseye.com/coverage.html#basic_conditionDecision">condition/decision 
coverage</A>. Modified condition/decision coverage was designed for languages 
containing logical operators that do not short-circuit. The short circuit 
logical operators in C, C++ and Java only evaluate conditions when their result 
can affect the encompassing decision. The paper that defines this measure [<A 
href="http://www.bullseye.com/coverage.html#Chilenski1994">Chilenski1994</A>] 
section "3.3 Extensions for short-circuit operators" says "[use of short-circuit 
operators] forces relaxation of the requirement that all conditions are held 
fixed while the condition of interest is varied." The only programming language 
referenced by this paper is <A 
href="http://archive.adaic.com/standards/83lrm/html/lrm-TOC.html">Ada</A>, which 
has logical operators that do not short circuit as well as those that do. 
<H3><A name=basic_path>Path Coverage </A></H3>
<P>This measure reports whether each of the possible paths in each function have 
been followed. A path is a unique sequence of branches from the function entry 
to the exit. 
<P>Also known as predicate coverage. Predicate coverage views paths as possible 
combinations of logical conditions [<A 
href="http://www.bullseye.com/coverage.html#beizer1990">Beizer1990</A> p.98]. 
<P>Since loops introduce an unbounded number of paths, this measure considers 
only a limited number of looping possibilities. A large number of variations of 
this measure exist to cope with loops. Boundary-interior path testing considers 
two possibilities for loops: zero repetitions and more than zero repetitions [<A 
href="http://www.bullseye.com/coverage.html#ntafos1988">Ntafos1988</A>]. For 
do-while loops, the two possibilities are one iteration and more than one 
iteration. 
<P>Path coverage has the advantage of requiring very thorough testing. Path 
coverage has two severe disadvantages. The first is that the number of paths is 
exponential to the number of branches. For example, a function containing 10 
<CODE>if</CODE>-statements has 1024 paths to test. Adding just one more 
<CODE>if</CODE>-statement doubles the count to 2048. The second disadvantage is 
that many paths are impossible to exercise due to relationships of data. For 
example, consider the following C/C++ code fragment: <PRE>if (success)
    statement1;
statement2;
if (success)
    statement3;
</PRE>
<P>Path coverage considers this fragment to contain 4 paths. In fact, only two 
are feasible: success=false and success=true. 
<P>Researchers have invented many variations of path coverage to deal with the 
large number of paths. For example, n-length sub-path coverage reports whether 
you exercised each path of length n branches. Others variations include <A 
href="http://www.bullseye.com/coverage.html#other_lcsaj">linear code sequence 
and jump (LCSAJ) coverage</A> and <A 
href="http://www.bullseye.com/coverage.html#other_dataFlow">data flow 
coverage</A>. 
<H2><A name=other>Other Measures</A></H2>
<P>Here is a description of some variations of the fundamental measures and some 
less commonly use measures. 
<H3><A name=other_function>Function Coverage </A></H3>
<P>This measure reports whether you invoked each function or procedure. It is 
useful during preliminary testing to assure at least some coverage in all areas 
of the software. Broad, shallow testing finds gross deficiencies in a test suite 
quickly. 
<P><A href="http://www.bullseye.com/index.html">BullseyeCoverage</A> measures 
function coverage. 
<H3><A name=other_call>Call Coverage </A></H3>
<P>This measure reports whether you executed each function call. The hypothesis 
is that <A 
href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A> commonly 
occur in interfaces between modules. 
<P>Also known as call pair coverage. 
<H3><A name=other_lcsaj>Linear Code Sequence and Jump (LCSAJ) Coverage </A></H3>
<P>This variation of <A 
href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A> 
considers only sub-paths that can easily be represented in the program source 
code, without requiring a flow graph. An LCSAJ is a sequence of source code 
lines executed in sequence. This "linear" sequence can contain decisions as long 
as the control flow actually continues from one line to the next at run-time. 
Sub-paths are constructed by concatenating LCSAJs. Researchers refer to the 
coverage ratio of paths of length n LCSAJs as the test effectiveness ratio (TER) 
n+2. 
<P>The advantage of this measure is that it is more thorough than <A 
href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A> yet avoids the exponential difficulty of <A 
href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A>. The 
disadvantage is that it does not avoid infeasible paths. 
<H3><A name=other_dataFlow>Data Flow Coverage </A></H3>
<P>This variation of <A 
href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A> 
considers only the sub-paths from variable assignments to subsequent references 
of the variables. 
<P>The advantage of this measure is the paths reported have direct relevance to 
the way the program handles data. One disadvantage is that this measure does not 
include <A href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A>. Another disadvantage is complexity. Researchers have proposed 
numerous variations, all of which increase the complexity of this measure. For 
example, variations distinguish between the use of a variable in a computation 
versus a use in a decision, and between local and global variables. As with data 
flow analysis for code optimization, pointers also present problems. 
<H3><A name=other_object>Object Code Branch Coverage </A></H3>
<P>This measure reports whether each machine language conditional branch 
instruction both took the branch and fell through. 
<P>This measure gives results that depend on the compiler rather than on the 
program structure since compiler code generation and optimization techniques can 
create object code that bears little similarity to the original source code 
structure. 
<P>Since branches disrupt the instruction pipeline, compilers sometimes avoid 
generating a branch and instead generate an equivalent sequence of non-branching 
instructions. Compilers often expand the body of a function inline to save the 
cost of a function call. If such functions contain branches, the number of 
machine language branches increases dramatically relative to the original source 
code. 
<P>You are better off testing the original source code since it relates to 
program requirements better than the object code. 
<H3><A name=other_loop>Loop Coverage </A></H3>
<P>This measure reports whether you executed each loop body zero times, exactly 
once, and more than once (consecutively). For do-while loops, loop coverage 
reports whether you executed the body exactly once, and more than once. 
<P>The valuable aspect of this measure is determining whether 
<CODE>while</CODE>-loops and <CODE>for</CODE>-loops execute more than once, 
information not reported by others measure. 
<P>As far as I know, only <A 
href="ftp://cs.uiuc.edu/pub/testing/GCT.README">GCT</A> implements this measure. 

<H3><A name=other_race>Race Coverage </A></H3>
<P>This measure reports whether multiple threads execute the same code at the 
same time. It helps detect failure to synchronize access to resources. It is 
useful for testing multi-threaded programs such as in an operating system. 
<P>As far as I know, only <A 
href="ftp://cs.uiuc.edu/pub/testing/GCT.README">GCT</A> implements this measure. 

<H3><A name=other_relational>Relational Operator Coverage </A></H3>
<P>This measure reports whether boundary situations occur with relational 
operators (&lt;, &lt;=, &gt;, &gt;=). The hypothesis is that boundary test cases 
find off-by-one <A 
href="http://www.bullseye.com/coverage.html#glossary_error">errors</A> and 
mistaken uses of wrong relational operators such as &lt; instead of &lt;=. For 
example, consider the following C/C++ code fragment: <PRE>if (a &lt; b)
    statement;
</PRE>
<P>Relational operator coverage reports whether the situation a==b occurs. If 
a==b occurs and the program behaves correctly, you can assume the relational 
operator is not suppose to be &lt;=. 
<P>As far as I know, only <A 
href="ftp://cs.uiuc.edu/pub/testing/GCT.README">GCT</A> implements this measure. 

<H3><A name=other_mutation>Weak Mutation Coverage </A></H3>
<P>This measure is similar to <A 
href="http://www.bullseye.com/coverage.html#other_relational">relational 
operator coverage</A> but much more general [<A 
href="http://www.bullseye.com/coverage.html#howden1982">Howden1982</A>]. It 
reports whether test cases occur which would expose the use of wrong operators 
and also wrong operands. It works by reporting coverage of conditions derived by 
substituting (mutating) the program's expressions with alternate operators, such 
as "-" substituted for "+", and with alternate variables substituted. 
<P>This measure interests the academic world mainly. Caveats are many; programs 
must meet special requirements to enable measurement. 
<P>As far as I know, only <A 
href="ftp://cs.uiuc.edu/pub/testing/GCT.README">GCT</A> implements this measure. 

<H3><A name=other_table>Table Coverage </A></H3>
<P>This measure indicates whether each entry in a particular array has been 
referenced. This is useful for programs that are controlled by a finite state 
machine. 
<H2><A name=compare>Comparing Measures</A></H2>
<P>You can compare relative strengths when a stronger measure includes a weaker 
measure. 
<UL>
  <LI><A href="http://www.bullseye.com/coverage.html#basic_decision">Decision 
  coverage</A> includes <A 
  href="http://www.bullseye.com/coverage.html#basic_statement">statement 
  coverage</A> since exercising every branch must lead to exercising every 
  statement. 
  <LI><A 
  href="http://www.bullseye.com/coverage.html#basic_conditionDecision">Condition/decision 
  coverage</A> includes <A 
  href="http://www.bullseye.com/coverage.html#basic_decision">decision 
  coverage</A> and <A 
  href="http://www.bullseye.com/coverage.html#basic_condition">condition 
  coverage</A> (by definition). 
  <LI><A href="http://www.bullseye.com/coverage.html#basic_path">Path 
  coverage</A> includes <A 
  href="http://www.bullseye.com/coverage.html#basic_decision">decision 
  coverage</A>. 
  <LI><A href="http://www.bullseye.com/coverage.html#basic_path">Predicate 
  coverage</A> includes <A 
  href="http://www.bullseye.com/coverage.html#basic_path">path coverage</A> and 
  <A 
  href="http://www.bullseye.com/coverage.html#basic_conditionMultiple">multiple 
  condition coverage</A>, as well as most other measures. </LI></UL>
<P>Academia says the stronger measure <DFN>subsumes</DFN> the weaker measure. 
<P>Coverage measures cannot be compared quantitatively. 
<H2><A name=release>Coverage Goal for Release</A></H2>
<P>Each project must choose a minimum percent coverage for release criteria 
based on available testing resources and the importance of preventing 
post-release <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A>. 
Clearly, safety-critical software should have a high goal. You might set a 
higher coverage goal for unit testing than for system testing since a <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failure</A> in 
lower-level code may affect multiple high-level callers. 
<P>Using <A 
href="http://www.bullseye.com/coverage.html#basic_statement">statement 
coverage</A>, <A 
href="http://www.bullseye.com/coverage.html#basic_decision">decision 
coverage</A>, or <A 
href="http://www.bullseye.com/coverage.html#basic_conditionDecision">condition/decision 
coverage</A> you generally want to attain 80%-90% coverage or more before 
releasing. Some people feel that setting any goal less than 100% coverage does 
not assure quality. However, you expend a lot of effort attaining coverage 
approaching 100%. The same effort might find more <A 
href="http://www.bullseye.com/coverage.html#glossary_fault">faults</A> in a 
different testing activity, such as <A 
href="http://www.ics.hawaii.edu/~johnson/FTR/">formal technical review</A>. 
Avoid setting a goal lower than 80%. 
<H2><A name=intermediate>Intermediate Coverage Goals</A></H2>
<P>Choosing good intermediate coverage goals can greatly increase testing 
productivity. 
<P>Your highest level of testing productivity occurs when you find the most <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A> with 
the least effort. Effort is measured by the time required to create test cases, 
add them to your test suite and run them. It follows that you should use a 
coverage analysis strategy that increases coverage as fast as possible. This 
gives you the greatest probability of finding <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A> 
sooner rather than later. Figure 1 illustrates the coverage rates for high and 
low productivity. Figure 2 shows the corresponding <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failure</A> 
discovery rates. 
<P><IMG alt="Figure 1 and figure 2" 
src="Code Coverage Analysis_archivos/f1f2.png"> 
<P>One strategy that usually increases coverage quickly is to first attain some 
coverage throughout the entire test program before striving for high coverage in 
any particular area. By briefly visiting each of the test program features, you 
are likely to find obvious or gross <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A> 
early. For example, suppose your application prints several types of documents, 
and a <A href="http://www.bullseye.com/coverage.html#glossary_fault">fault</A> 
exists which completely prevents printing one (and only one) of the document 
types. If you first try printing one document of each type, you probably find 
this <A href="http://www.bullseye.com/coverage.html#glossary_fault">fault</A> 
sooner than if you thoroughly test each document type one at a time by printing 
many documents of that type before moving on to the next type. The idea is to 
first look for <A 
href="http://www.bullseye.com/coverage.html#glossary_failure">failures</A> that 
are easily found by minimal testing. 
<P>The sequence of coverage goals listed below illustrates a possible 
implementation of this strategy. 
<OL>
  <LI>Invoke at least one function in 90% of the source files (or classes). 
  <LI>Invoke 90% of the functions. 
  <LI>Attain 90% <A 
  href="http://www.bullseye.com/coverage.html#basic_conditionDecision">condition/decision 
  coverage</A> in each function. 
  <LI>Attain 100% <A 
  href="http://www.bullseye.com/coverage.html#basic_conditionDecision">condition/decision 
  coverage</A>. </LI></OL>
<P>Notice we do not require 100% coverage in any of the initial goals. This 
allows you to defer testing the most difficult areas. This is crucial to 
maintaining high testing productivity; achieve maximum results with minimum 
effort. 
<P>Avoid using a weaker measure for an intermediate goal combined with a 
stronger measure for your release goal. Effectively, this allows the weaknesses 
in the weaker measure to decide which test cases to defer. Instead, use the 
stronger measure for all goals and allow the difficulty of the individual test 
cases help you decide whether to defer them. 
<H2><A name=summary>Summary</A></H2>
<P>Coverage analysis is a structural testing technique that helps eliminate gaps 
in a test suite. It helps most in the absence of a detailed, up-to-date 
requirements specification. <A 
href="http://www.bullseye.com/coverage.html#basic_conditionDecision">Condition/decision 
coverage</A> is the best general-purpose measure for C, C++, and Java. Setting 
an intermediate goal of 100% coverage (of any type) can impede testing 
productivity. Before releasing, strive for 80%-90% or more coverage of 
statements, branches, or conditions. 
<H2><A name=refer>References</A></H2>
<P><A name=beizer1990><STRONG>Beizer1990</STRONG></A> Beizer, Boris, "Software 
Testing Techniques", 2nd edition, New York: Van Nostrand Reinhold, 1990 
<P><A name=Chilenski1994><STRONG>Chilenski1994</STRONG></A> John Joseph 
Chilenski and Steven P. Miller, "Applicability of Modified Condition/Decision 
Coverage to Software Testing", Software Engineering Journal, September 1994, 
Vol. 9, No. 5, pp.193-200. 
<P><A name=do178b><STRONG>RTCA/DO-178B</STRONG></A>, "Software Considerations in 
Airborne Systems and Equipment Certification", <A 
href="http://www.rtca.org/">RCTA</A>, December 1992, pp.31, 74. 
<P><A name=howden1982><STRONG>Howden1982</STRONG></A> "Weak Mutation Testing and 
Completeness of Test Sets", <EM>IEEE Trans. Software Eng.</EM>, Vol.SE-8, No.4, 
July 1982, pp.371-379. 
<P><STRONG>McCabe1976</STRONG> McCabe, Tom, "A Software Complexity Measure", 
<EM>IEEE Trans. Software Eng.</EM>, Vol.2, No.6, December 1976, pp.308-320. 
<P><A name=morell1990><STRONG>Morell1990</STRONG></A> Morell, Larry, "A Theory 
of Fault-Based Testing", <EM>IEEE Trans. Software Eng.</EM>, Vol.16, No.8, 
August 1990, pp.844-857. 
<P><A name=ntafos1988><STRONG>Ntafos1988</STRONG></A> Ntafos, Simeon,"A 
Comparison of Some Structural Testing Strategies", <EM>IEEE Trans. Software 
Eng.</EM>, Vol.14, No.6, June 1988, pp.868-874. 
<P><A name=roper1994><STRONG>Roper1994</STRONG></A> Roper, Marc, "Software 
Testing", London, McGraw-Hill Book Company, 1994 
<H2><A name=glossary>Glossary</A></H2>
<P><A name=glossary_fault><STRONG>Fault</STRONG></A> - A bug. A defect. 
<P><A name=glossary_error><STRONG>Error</STRONG></A> - A mistake made by a 
person that results in a fault. 
<P><A name=glossary_failure><STRONG>Failure</STRONG></A> - The run-time 
manifestation of a fault. 
<HR>

<P style="FONT-SIZE: xx-small"><A 
href="http://www.bullseye.com/copyright.html">Copyright © Bullseye Testing 
Technology</A> </P></BODY></HTML>

<!-- neodl3.grp.bf1.yahoo.com Sun Apr 15 15:19:05 UTC 2018 -->
